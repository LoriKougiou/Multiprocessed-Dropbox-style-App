SYSPRO PROJECT 2--README
ΛΟΡΙ ΚΟΥΓΙΟΥΜΤΖΙΑΝ 		ΑΜ: 1115201400076

compile: make
run: ./mirror_client -n 1 -c ./common -i ./1_input -m ./1_mirror -b 100 -l log_file1 (τα νουμερα ειναι ενδεικτικα όπως και η σειρα των ορισματων)

Το project αποτελείται από τα παρακάτω αρχεία:
-hash.c/.h
-checkDirs.c/.h
-dirManagement.c/.h
-childWork.c/.h
-sighandle.c/.h
-readwrite.c/.h
-main.c
-Makefile
και τα scripts create_infiles.sh, get_stats.sh

--hash.c/.h
Περιέχει την δομή και συναρτήσεις δημιουργίας και καταστροφή ενός hashtable που κρατάει όλα τα ids που μπαίνουν στο σύστημα. Για κάθε ένα απο αυτά, κρατάει μια μεταβλητή status την οποία αυξάνει κατα 1 σε κάθε κύκλο ελέγχου του common dir εάν βρεί το αντίστοιχο .id αρχειο. Η μεταβλητή αυτή χρησιμέυει για να καταλάβει ο client ποιοι clients εχουν αποχωρήσει και να σβήσει τα αντιστοιχα dirs από το mirror του.

--sighandle.c/.h
Περιέχει τη δομή sigList_node η οποία κρατά τα δεδομένα από το fork που έκάνε ο πατέρας για κάθε νέο client που βρίσκει, έτσι ώστε να διευκολύνεται στην διαχείρηση των signals.Περιέχει επίσης και δυο volatile variables, την signaled και την sigSender που ο myHandler τις θέτει κατάλληλα έτσι ώστε ο πατέρας να καταλαβαίνει ποιο σήμα έλαβε και από ποιο process μέχω της siginfo δομής που περνιέται ώς ορισμα στου handler.

--checkDirs.c/.h
Περιέχει τις συναρτήσεις που κάνουν τους αρχικού ελέγχους για τα input, mirror και common directories, όπως επίσης και συνάρτηση που ελέγχει εάν ένας client id στο common είναι καινούργιο ή όχι, για να δεί εάν πρέπει ο client να συγχρονιστεί μαζί του η όχι. Περιέχει επίσης τη συνάρτηση που δημιουργεί το νέο id file στο common όταν εισέρχεται νέος client. Η βασικότερη συνάρτηση του αρχείου είναι η checkCommon, η οποία καλείται περιοδικά από την main. Αυτή, αφού κάνει setup τον signal handler με την sigaction για τα σήματα SIGSEGV, SIGINT, SIGQUIT, SIGUSR1, SIGUSR2, εκτελεί τον έλεγχο του common dir για νέους client, και εφόσον βρείο νέο client τοτε πράττει ως εξής:
1) Δεσμεύει νεο node στην λίστα sigList που κρατάει τα δεδομένα όλων των forking για να διευκολύνει το signal handling.
2) Κάνει fork τον sender , κάνει setup τον handler για τον sender με SIGTERM, SIGPIPE, SIGSEGV, και καλέι την συνάρτηση senderWork μέσω της οποίας το παιδί δημιουργεί το senderfifo (αν δεν έχει δημιουργηθεί) και προσπαθεί να στείλει το input του. 
3) Κάνει fork τον receiver , κάνει setup τον handler για τον sender με SIGTERM, SIGPIPE, SIGSEGV, και καλέι την συνάρτηση receiverWork μέσω της οποίας το παιδί δημιουργεί το receiverfifo (αν δεν έχει δημιουργηθεί) και προσπαθεί να λάβει το input του άλλου client.
4) Ο πατέρας συνεχίζει τον έλεγχο στο common για νέο client.
5) Ο πατέρας μπλοκάρει όλα τα σήματα ελέγχει την volatile μεταβλητή signaled, και ανάλογα με την τιμή που της έχει dωσει ο signal handler  αναγωρίζει για ποιό signal πρόκειτα και δρα αναλόγως. 
	α) Στην περίπτωση που πρόκειτα για SIGUSR1 ,δηλαδη για σήμα αποτυχίας μεταφοράς απο κάποιο παιδί, τότε ο πατέρας βρίσκει από την sigList από ποιον client προέρχεται το παιδί, και σκοτώνει και τα δύο παιδιά και διαγράφει (εάν δεν έχουν διαγραφεί) τα fifo files, και το directory του mirror του που αντιστοιχει στον client απο τον οποίο ήρθε το σήμα. Εάν έχει ακόμα διαθέσιμο retry με τον συγκεκριμένο client, ο πατέρας ξαναπροσπαθεί να κάνει fork και επανεκιννεί την διαδικασία μεταφοράς.
	β) Εάν πρόκειται για SIGUSR1 ή SIGQUIT, σβήνει το mirror του και το .id αρχείο του από το common και κάνει ομαλή έξοδο.
	γ) Εάν πρόκειται για SIGUSR2 γράφει στο logfile ότι η λήψη/αποστολή ήταν επιτυχής,  αφού ανιχνεύσει με ποιόν client σχετίζεται το process που έστειλε το σήμα.
 Στη συνέχει ξεμπλοκάρει τα σήματα και εξέρχεται από τον έλεγχο.

6) Ελέγχει το hashtable και τα status των ids, και εάν δεν εείναι ίσα με το current status του συγκεκριμένου ελέγχου, τότε ο client σβήνει από το mirror του τον φάκελο που αντιστοιχεί στον κάθε client που έχει αποχωρήσει από το σύστημα.

--dirManagement.c/.h
Περιέχει τις δομές και συναρτήσεις που φτιάχνουν τις λίστες από directories που κάνει access με βάθος ο writer γράφοντας αυτά και τα αρχεία που περιέχουν στο pipe για να τα διαβάσει ο reader.

--readwrite.c/.h
Περιέχει τις συναρτήσεις reader και writer. Η reader ανοιγει το fifo  σε blocking mode για ανάγνωση και κάνει setup μια poll διαδικασία που παρακολουθεί των file descriptor του reader, και εάν εντός 30 δευτερολέπτων έχει λάβει input από το fifo συνεχίζει κανονικά την ανάγνωση από αυτό μέχρι να λάβει 00 όποτ επιστρέφει 1, ή να προκύψει κάποιο πρόβλημα (πχ εάν ο sender εξαφανιστεί από το σύστημα στη μέση της διαδικασιας). Αλλίως εαν περάσουν 30 secs τρωει timeout και τερματίζει επιστρέφοντας 0.
Αντίστοιχα ο writer ανοίγει το fifo σε blocking mode και όταν ανοίξει η απέναντι πλευρά τοτε αρχίζει να στέλνει τα δεδομένα, έχοντας φυσικά αξιοποιήσει τις συναρτήσεις και δομές του dirManagement για να έχει τη λίστα με τα directories τα οποία πρέπει να προσπελάσει και να στείλει τα αρχεία. Εάν όλα κυλήσουν ομαλά γράφει 00 στο pipe και επιστρέφει 1. Αλλιώς εάν κάτι παει στραβά σε οποιοδήποτε σημείο (πχ ο reader εξαφανιστεί και ο writer φαει sigpipe) τοτε επιστρέφει 0.

--childWork.c/.h
Περιέχει τις δύο συναρτήσεις που καλούν τα child processes, την senderWork και την receiverWork. Σ'αυτές το παιδία δημιουργεί το fifo που θα χρησιμοποιήσει (εαν αυτό δεν υπάρχει) και καλέι την reader/writer συνάρτηση αντίστοιχα. Εάν η reader/writer εκτελεστεί επιτυχώς τότε το παιδί στέλνει SIGUSR2 στον πατέρα και τερματίζει με exit code 0. Αλλιώς εάν προκύψει πρόβλημα, στέλνει SIGUSR1 στον πατέρα και τερματίζει με exit code 1.

--main.c
Ελέγχει και αποθηκεύει τα ορίσματα της γραμμής εντολών, κάνει τους αρχικούς ελέγχους των directories και αφού προσθέσει στο common το αρχείο .id που του αντιστοιχεί, ελέγχει περιοδικά το common directory για νέους clients. Εάν φάει SIGINT ή SIGQUIT, σβήνει το αναγνωριστικό αρχείο του και το mirror του και  τότε απελευθερώνει ότι μνήμη έχει δεσμέυσει και κάνει έξοδο από το πρόγραμμα.

--create_infiles.sh
Δημιουργεί μια ιεραρχία φακέλων όπως η ζητούμενη , με βάση την roundrobin διαδικασια. Έχω υλοποιήσει τη παραγωγή strings με δικές μου συναρτήσεις και δουλεύει μια χαρά, αλλα έχω και σχολιασμένη την επιλογή της urandom , διότι είναι λίγο πιο γρήγορη.

--get_stats.sh
Υλοποιεί αυτό που ζητείται. Διαβάζει γραμμη γραμμή το συνολικό logfile και ελεγχει λέξη λέξη και βασιζόμενο σε κάποια key words του logfile γάζει τα ζητούμενα στατιστικα για την εκτέλεση.

Το πρόγραμμα αναπτύχθηκε σε περιβάλλον ubuntu 18.04, κάνει compile και τρέχει και στα μηχανήματα της σχολης.
